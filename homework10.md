10.1 实验目标：虚存管理

* 缺页和页访问非法的返回地址有什么不同？
	* P位

* 虚拟内存管理中是否用到了段机制？
	* 有

* ucore如何知道页访问异常的地址？
	* 缺页异常处理例程会传地址给pgfault_handler函数。

10.2 回顾历史和了解当下

* 中断处理例程的段表在GDT还是LDT？
	* GDT

* 物理内存管理的数据结构在哪？
	* 页表，起始地址在CR3中

* 页表项的结构？
	* 物理页帧号+标志位

* 页表项的修改代码？
	* 在缺页异常中修改

* 如何设置一个虚拟地址到物理地址的映射关系？
	* 页表机制

* 为了建立虚拟内存管理，需要在哪个数据结构中表示“合法”虚拟内存
	* vma_struct

10.3 处理流程、关键数据结构和功能

* swap_init()做了些什么？
	* 建立交换分区

* vmm_init()做了些什么？
	* 建立模拟环境进行对虚拟内存管理的测试

* vma_struct数据结构的功能？
	* 表示“合法”的虚拟内存块

* mmap_list是什么列表？
	* 对应的物理地址排序后的列表

* 外存中的页面后备如何找到？
	* 在swap分区中

* vma_struct和mm_struct的关系是什么？
	* vma_struct:合法的连续虚拟地址区域
	* mm_struct:整个进程的地址空间

* 画数据结构图，描述进程的虚拟地址空间、页表项、物理页面和后备页面的关系；

10.4 页访问异常

* 页面不在内存和页面访问非法的处理中有什么区别？对应的代码区别在哪？
	* 不在内存时需要处理缺页，页面访问非法时需要报错。
	* 区别在pgfault_handler中。

* find_vma()做了些什么？
	* 查找合法逻辑地址所对应的vma数据结构

* swapfs_read()做了些什么？
	* 将磁盘中暂存的数据换入内存

* 缺页时的页面创建代码在哪？
	* page_insert

* struct rb_tree数据结构的原理是什么？在虚拟管理中如何用它的？
	* 红黑树，用于管理内存块，加快查找速度。

* 页目录项和页表项的dirty bit是何时，由谁置1的？
	* 修改对应页面时，由软件置1

* 页目录项和页表项的access bit是何时，由谁置1的？
	* 试图访问对应页面时，由硬件置1

10.5 页换入换出机制

* 虚拟页与磁盘后备页面的对应有关系？
	* 页表项中P位为0时，页表项内容为struct swap_entry_t，用offset表示虚拟页与磁盘中后备页面的对应关系。

* 如果在开始加载可执行文件时，如何改？

* check_swap()做了些什么检查？
	* 替换算法能否正确完成

* swap_entry_t数据结构做什么用的？放在什么地方？
	* 表示虚拟页与磁盘中后备页面的对应关系，在PTE中。

* 空闲物理页面的组织数据结构是什么？
	* Page

* 置换算法的接口数据结构
	* swap_manager


